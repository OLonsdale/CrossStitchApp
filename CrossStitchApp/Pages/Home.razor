@page "/"
@using CrossStitchApp.Models
@using System.Text.Json
@using MudBlazor.Utilities
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

<PageTitle>Cross Stitch App</PageTitle>

<style>
    html {
        background-color: @backgroundColor !important;
        font-family: sans-serif;
    }

    table {
        border-spacing: 0;
        border-collapse: collapse;
    }

    td {
        @(showGrid ? $"border: solid {gridColor} 1px;" : "");
        min-width: @(cellSize)px;
        height: @(cellSize)px;
    }

    .stitched {
        background-image: url(/cross.svg) !important;
        background-size: 100% 100%;
        background-repeat: no-repeat !important;
        background-position: center !important;
    }

    .main{
        max-height: 95vh;
        max-width: 100vw;
        overflow-x: scroll;
        overflow-y: scroll;
    }

</style>

<script>
    window.CellClicked = (x, y) => {
        DotNet.invokeMethod('CrossStitchApp', 'CellClicked', x, y)
    };
</script>

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

<MudToolBar WrapContent Dense  Style="width: 100vw; height: 4vh; overflow-y: scroll">
    <MudButton Size="Size.Small" Color="Color.Surface" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Brush" OnClick="@( () => SetGameState("draw"))">Draw</MudButton>
    <MudButton Size="Size.Small" Color="Color.Surface" Variant="Variant.Filled" EndIcon="@CustomIcons.Stitch" OnClick="@( () => SetGameState("stitch"))">Stitch</MudButton>

    <div class="ml-2" />

    <MudButton Size="Size.Small" Color="Color.Surface" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Clear" OnClick="@( ()=> ResetGrid(true))">Clear</MudButton>
    <MudButton Size="Size.Small" Color="Color.Surface" Variant="Variant.Filled" EndIcon="@Icons.Material.Filled.Undo" OnClick="Undo">Undo</MudButton>
    <MudSpacer />
    @if (gameState == "draw")
    {
        <div class="ml-2" >
            <MudAvatar Style="cursor: pointer" Rounded="@(color != null)" Size="Size.Small" Elevation="5" @onclick="@(() => SetColor(null))"> <MudIconButton Icon="@CustomIcons.Erase" /> </MudAvatar>
            @foreach (var colorCode in colors)
            {
                <MudAvatar Rounded="@(color != colorCode)" Size="Size.Small" Elevation="5" @onclick="@(() => SetColor(colorCode))" Style="@($"background-color: {colorCode};cursor: pointer;")" />
            }
            <MudAvatar Style="@($"background-color: {color};cursor: pointer;")" Rounded @onclick="@( () => colorsOpen = true)" Size="Size.Small" Elevation="5"><MudIcon Icon="@CustomIcons.ColorPallet" /></MudAvatar>
        </div>
        @* <MudButton Size="Size.Small" Variant="Variant.Outlined" EndIcon="@CustomIcons.FloodFill" OnClick="@(() => floodFillActive = true)">Flood Fill</MudButton> *@

    }

    <MudSpacer />

    <MudIconButton Icon="@Icons.Material.Filled.Save" OnClick="@( () => savesOpen = true)" />
    <MudIconButton Icon="@Icons.Material.Filled.Settings" OnClick="@( () => settingsOpen = true)" />

</MudToolBar>

<MudDialog @bind-IsVisible="settingsOpen">
    <TitleContent>
        <MudText Typo="Typo.h6">Settings</MudText>
    </TitleContent>
    <DialogContent>
        <MudNumericField Min="1" Max="500" @bind-Value="gridHeight" Label="Grid Height" />
        <MudNumericField Min="1" Max="500" @bind-Value="gridWidth" Label="Grid Width" />
        <MudNumericField Min="1" Max="500" @bind-Value="cellSize" Label="Cell Size" />
        Background Colour:
        <MudInput DisableUnderLine Class="ml-2" Style="width:10em; height: 5em" InputType="InputType.Color" @bind-Value="backgroundColor" />


         <MudCheckBox @bind-Value="showGrid">Show Grid</MudCheckBox>
     </DialogContent>
 </MudDialog>

 <MudDialog @bind-IsVisible="savesOpen">
     <TitleContent><MudText Typo="Typo.h6">Saves</MudText></TitleContent>
     <DialogContent>
         <MudButton Variant="Variant.Outlined" OnClick="Export">Download</MudButton>
         <MudButton Variant="Variant.Outlined" OnClick="Import">Import from below text</MudButton>
         <MudTextField @bind-Value="imported" />
     </DialogContent>
 </MudDialog>

 <MudDialog @bind-IsVisible="colorsOpen">
     <TitleContent><MudText Typo="Typo.h6">Colours</MudText></TitleContent>
     <DialogContent>
         <MudStack AlignItems="AlignItems.Center">
             <MudItem>
                 @foreach (var colorCode in colors)
                {
                    <MudAvatar Rounded="@(color != colorCode)" Size="Size.Small" Elevation="5" @onclick="@(() => SetColor(colorCode))" Style="@($"background-color: {colorCode}; cursor: pointer")" />
                }
            </MudItem>

            <MudInput DisableUnderLine Class="ml-2" Style="width:10em; height: 5em" InputType="InputType.Color" @bind-Value="color" />
            
                    @* <MudInput DisableUnderLine Style="width:10em; min-height: 5em" InputType="InputType.Color" @bind-Value="color" /> *@
             <MudButton Size="Size.Small" Variant="Variant.Outlined" EndIcon="@Icons.Material.Filled.Save" OnClick="@(() => colors.Add(color))">Add To Pallet</MudButton>
             <MudButton Size="Size.Small" Variant="Variant.Outlined" EndIcon="@Icons.Material.Filled.Delete" OnClick="@(() => colors.Remove(color))">Remove From Pallet</MudButton>
             <MudButton Size="Size.Small" Variant="Variant.Outlined" EndIcon="@CustomIcons.ColorPicker" OnClick="@(() => pickerActive = true)">Pick Colour From Grid</MudButton>
         </MudStack>
     </DialogContent>
 </MudDialog>

 <div class="main">
    <table >
            @for (int rowIndex = 0; rowIndex < grid.GetLength(0); rowIndex++)
        {
            <tr>
                @for (int colIndex = 0; colIndex < grid.GetLength(1); colIndex++)
                {
                    var cell = grid[rowIndex, colIndex];
                    int row = rowIndex;
                    int col = colIndex;
                    string classStr = cell.Stitched ? "stitched" : "not-stitched" ?? "not-stitched";
                    <td draggable class="@classStr" style="background-color:@cell.Color" onclick="CellClicked(@row,@col)" ondragenter="CellClicked(@row,@col)" />

                }
            </tr>
        }
    </table>
 </div>


@code {
    string? color = "#ffffff";
    Tile[,] grid = new Tile[0, 0];
    string gridColor = "black";
    int cellSize = 10;
    string backgroundColor = "#ffffff";
    bool showGrid = true;
    public static event Action<(int, int)> OnCellClicked;
    string gameState = "draw";
    bool pickerActive = false;
    bool floodFillActive = false;
    string imported = "";
    bool settingsOpen = false;
    bool savesOpen = false;
    bool colorsOpen = false;
    List<SaveFile> Saves = new();
    List<(Tile, string, bool)> History = new();
    HashSet<string> colors = new()
    {
        "#FF0000",
        "#FF6A00",
        "#FFD800",
        "#4CFF00",
        "#0026FF",
        "#B200FF",
        "#FFFFFF",
        "#000000",
    };


    int _gridHeight = 50;
    int _gridWidth = 100;
    int gridHeight
    {
        set
        {
            _gridHeight = value;
            ResetGrid();
        }
        get
        {
            return _gridHeight;
        }
    }
    int gridWidth
    {
        set
        {
            _gridWidth = value;
            ResetGrid();
        }
        get
        {
            return _gridWidth;
        }
    }

    void SetGameState(string State)
    {
        gameState = State;
    }

    void SetColor(string? Color)
    {
        color = Color;
    }

    async void Export()
    {
        Console.WriteLine("Export Start");
        Tile[] flat = new Tile[gridWidth * gridHeight];

        int i = 0;
        for (int rowIndex = 0; rowIndex < grid.GetLength(0); rowIndex++)
        {
            for (int colIndex = 0; colIndex < grid.GetLength(1); colIndex++)
            {
                flat[i] = grid[rowIndex, colIndex];
                i++;
            }
        }

        var saveFile = new SaveFile();
        saveFile.Data = flat;
        saveFile.Width = gridWidth;
        saveFile.Height = gridHeight;
        saveFile.Colors = colors;

        var data = JsonSerializer.SerializeToUtf8Bytes<SaveFile>(saveFile);
        var stream = new MemoryStream(data);
        var name = Guid.NewGuid().ToString();

        using var streamRef = new DotNetStreamReference(stream);
        Console.WriteLine("JS Invoke");

        await JSRuntime.InvokeVoidAsync("downloadFileFromStream", name, streamRef);
        Console.WriteLine("Export Finished");

    }

    void Import()
    {
        Console.WriteLine("Import Clicked");

        if (string.IsNullOrWhiteSpace(imported)) return;
        Console.WriteLine("Import Started");

        try
        {
            var saveFile = JsonSerializer.Deserialize<SaveFile>(imported);

            gridHeight = saveFile.Height;
            gridWidth = saveFile.Width;
            colors = saveFile.Colors;

            grid = new Tile[gridHeight, gridWidth];

            int i = 0;
            for (int rowIndex = 0; rowIndex < grid.GetLength(0); rowIndex++)
            {
                for (int colIndex = 0; colIndex < grid.GetLength(1); colIndex++)
                {
                    grid[rowIndex, colIndex] = saveFile.Data[i];
                    i++;
                }
            }

        }
        catch (Exception)
        {
            Console.WriteLine("Import Errored");
        }
        finally
        {
            imported = "";
            Console.WriteLine("Import Finished");
        }


    }

    void Undo()
    {
        if (!History.Any()) return;
        History.Last().Item1.Color = History.Last().Item2;
        History.Last().Item1.Stitched = History.Last().Item3;
        History.Remove(History.Last());
    }

    void CellClicked((int, int) xy)
    {
        var tile = grid[xy.Item1, xy.Item2];
        if (tile == null) return;

        if (pickerActive)
        {
            color = tile.Color ?? "#FFF";
            pickerActive = false;
            StateHasChanged();
            return;
        }

        if (floodFillActive && gameState == "draw")
        {
            FloodFill(xy.Item1, xy.Item2, color);
            floodFillActive = false;
            StateHasChanged();
            return;
        }

        if (gameState == "draw")
        {
            if (tile.Color == color) return;
            History.Add((tile, tile.Color, tile.Stitched));
            tile.Color = color;
        }
        else
        {
            History.Add((tile, tile.Color, tile.Stitched));
            tile.Stitched = !tile.Stitched;
        }

        StateHasChanged();
    }

    void FloodFill(int x, int y, string targetColor)
    {
        List<Tile> neighbours = new();
        int rows = grid.GetLength(0);
        int cols = grid.GetLength(1);

        if (x - 1 >= 0) neighbours.Add(grid[x - 1, y]);
        if (y - 1 >= 0) neighbours.Add(grid[x, y - 1]);
        if (y + 1 < cols) neighbours.Add(grid[x, y + 1]);
        if (x + 1 < rows) neighbours.Add(grid[x + 1, y]);

    }



    [JSInvokable]
    public static void CellClicked(int x, int y)
    {
        OnCellClicked?.Invoke((x, y));
    }

    protected override async Task OnInitializedAsync()
    {
        OnCellClicked += CellClicked;
        Console.WriteLine("Initialized");
        await ResetGrid(false);

    }

    async Task ResetGrid(bool confirm = true)
    {
        if (confirm)
        {
            var res = await DialogService.ShowMessageBox(title: "Reset Page?", "Are you sure you wish to reset the page? All progress not saved will be lost!", "Yes", "No");

            if(res != true)
            {
                return;
            }   
        }

        grid = new Tile[gridHeight, gridWidth];
        for (int i = 0; i < gridHeight; i++)
        {
            for (int j = 0; j < gridWidth; j++)
            {
                grid[i, j] = new();
            }
        }
    }


    public void Dispose()
    {
        OnCellClicked -= CellClicked;
    }

}